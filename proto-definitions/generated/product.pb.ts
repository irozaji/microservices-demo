// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.2.5
//   protoc               v5.28.3
// source: product.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "product";

export interface FindOneRequest {
  id: number;
}

export interface FindOneResponse {
  product: Product | undefined;
}

export interface DecreaseQuantityRequest {
  id: number;
  quantity: number;
}

export interface DecreaseQuantityResponse {
  success: boolean;
}

export interface CreateRequest {
  name: string;
  description: string;
  price: number;
  availableQuantity: number;
}

export interface CreateResponse {
  product: Product | undefined;
}

export interface UpdateRequest {
  id: number;
  name: string;
  description: string;
  price: number;
  availableQuantity: number;
}

export interface UpdateResponse {
  product: Product | undefined;
}

export interface DeleteRequest {
  id: number;
}

export interface DeleteResponse {
  success: boolean;
}

export interface FindAllRequest {}

export interface FindAllResponse {
  products: Product[];
}

export interface FindByIdsRequest {
  ids: number[];
}

export interface FindByIdsResponse {
  products: Product[];
}

export interface Empty {}

export interface Product {
  id: number;
  name: string;
  description: string;
  price: number;
  availableQuantity: number;
}

function createBaseFindOneRequest(): FindOneRequest {
  return { id: 0 };
}

export const FindOneRequest: MessageFns<FindOneRequest> = {
  encode(
    message: FindOneRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindOneRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindOneRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindOneRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: FindOneRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindOneRequest>, I>>(
    base?: I
  ): FindOneRequest {
    return FindOneRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindOneRequest>, I>>(
    object: I
  ): FindOneRequest {
    const message = createBaseFindOneRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseFindOneResponse(): FindOneResponse {
  return { product: undefined };
}

export const FindOneResponse: MessageFns<FindOneResponse> = {
  encode(
    message: FindOneResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindOneResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindOneResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindOneResponse {
    return {
      product: isSet(object.product)
        ? Product.fromJSON(object.product)
        : undefined,
    };
  },

  toJSON(message: FindOneResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindOneResponse>, I>>(
    base?: I
  ): FindOneResponse {
    return FindOneResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindOneResponse>, I>>(
    object: I
  ): FindOneResponse {
    const message = createBaseFindOneResponse();
    message.product =
      object.product !== undefined && object.product !== null
        ? Product.fromPartial(object.product)
        : undefined;
    return message;
  },
};

function createBaseDecreaseQuantityRequest(): DecreaseQuantityRequest {
  return { id: 0, quantity: 0 };
}

export const DecreaseQuantityRequest: MessageFns<DecreaseQuantityRequest> = {
  encode(
    message: DecreaseQuantityRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.quantity !== 0) {
      writer.uint32(16).int32(message.quantity);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): DecreaseQuantityRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecreaseQuantityRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.quantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecreaseQuantityRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      quantity: isSet(object.quantity) ? globalThis.Number(object.quantity) : 0,
    };
  },

  toJSON(message: DecreaseQuantityRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.quantity !== 0) {
      obj.quantity = Math.round(message.quantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecreaseQuantityRequest>, I>>(
    base?: I
  ): DecreaseQuantityRequest {
    return DecreaseQuantityRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecreaseQuantityRequest>, I>>(
    object: I
  ): DecreaseQuantityRequest {
    const message = createBaseDecreaseQuantityRequest();
    message.id = object.id ?? 0;
    message.quantity = object.quantity ?? 0;
    return message;
  },
};

function createBaseDecreaseQuantityResponse(): DecreaseQuantityResponse {
  return { success: false };
}

export const DecreaseQuantityResponse: MessageFns<DecreaseQuantityResponse> = {
  encode(
    message: DecreaseQuantityResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(
    input: BinaryReader | Uint8Array,
    length?: number
  ): DecreaseQuantityResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDecreaseQuantityResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DecreaseQuantityResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
    };
  },

  toJSON(message: DecreaseQuantityResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DecreaseQuantityResponse>, I>>(
    base?: I
  ): DecreaseQuantityResponse {
    return DecreaseQuantityResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DecreaseQuantityResponse>, I>>(
    object: I
  ): DecreaseQuantityResponse {
    const message = createBaseDecreaseQuantityResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseCreateRequest(): CreateRequest {
  return { name: "", description: "", price: 0, availableQuantity: 0 };
}

export const CreateRequest: MessageFns<CreateRequest> = {
  encode(
    message: CreateRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(18).string(message.description);
    }
    if (message.price !== 0) {
      writer.uint32(25).double(message.price);
    }
    if (message.availableQuantity !== 0) {
      writer.uint32(32).int32(message.availableQuantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.availableQuantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateRequest {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      availableQuantity: isSet(object.availableQuantity)
        ? globalThis.Number(object.availableQuantity)
        : 0,
    };
  },

  toJSON(message: CreateRequest): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.availableQuantity !== 0) {
      obj.availableQuantity = Math.round(message.availableQuantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateRequest>, I>>(
    base?: I
  ): CreateRequest {
    return CreateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateRequest>, I>>(
    object: I
  ): CreateRequest {
    const message = createBaseCreateRequest();
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.price = object.price ?? 0;
    message.availableQuantity = object.availableQuantity ?? 0;
    return message;
  },
};

function createBaseCreateResponse(): CreateResponse {
  return { product: undefined };
}

export const CreateResponse: MessageFns<CreateResponse> = {
  encode(
    message: CreateResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateResponse {
    return {
      product: isSet(object.product)
        ? Product.fromJSON(object.product)
        : undefined,
    };
  },

  toJSON(message: CreateResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateResponse>, I>>(
    base?: I
  ): CreateResponse {
    return CreateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateResponse>, I>>(
    object: I
  ): CreateResponse {
    const message = createBaseCreateResponse();
    message.product =
      object.product !== undefined && object.product !== null
        ? Product.fromPartial(object.product)
        : undefined;
    return message;
  },
};

function createBaseUpdateRequest(): UpdateRequest {
  return { id: 0, name: "", description: "", price: 0, availableQuantity: 0 };
}

export const UpdateRequest: MessageFns<UpdateRequest> = {
  encode(
    message: UpdateRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.price !== 0) {
      writer.uint32(33).double(message.price);
    }
    if (message.availableQuantity !== 0) {
      writer.uint32(40).int32(message.availableQuantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.availableQuantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateRequest {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      availableQuantity: isSet(object.availableQuantity)
        ? globalThis.Number(object.availableQuantity)
        : 0,
    };
  },

  toJSON(message: UpdateRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.availableQuantity !== 0) {
      obj.availableQuantity = Math.round(message.availableQuantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateRequest>, I>>(
    base?: I
  ): UpdateRequest {
    return UpdateRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateRequest>, I>>(
    object: I
  ): UpdateRequest {
    const message = createBaseUpdateRequest();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.price = object.price ?? 0;
    message.availableQuantity = object.availableQuantity ?? 0;
    return message;
  },
};

function createBaseUpdateResponse(): UpdateResponse {
  return { product: undefined };
}

export const UpdateResponse: MessageFns<UpdateResponse> = {
  encode(
    message: UpdateResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.product !== undefined) {
      Product.encode(message.product, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UpdateResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUpdateResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.product = Product.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UpdateResponse {
    return {
      product: isSet(object.product)
        ? Product.fromJSON(object.product)
        : undefined,
    };
  },

  toJSON(message: UpdateResponse): unknown {
    const obj: any = {};
    if (message.product !== undefined) {
      obj.product = Product.toJSON(message.product);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UpdateResponse>, I>>(
    base?: I
  ): UpdateResponse {
    return UpdateResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UpdateResponse>, I>>(
    object: I
  ): UpdateResponse {
    const message = createBaseUpdateResponse();
    message.product =
      object.product !== undefined && object.product !== null
        ? Product.fromPartial(object.product)
        : undefined;
    return message;
  },
};

function createBaseDeleteRequest(): DeleteRequest {
  return { id: 0 };
}

export const DeleteRequest: MessageFns<DeleteRequest> = {
  encode(
    message: DeleteRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteRequest {
    return { id: isSet(object.id) ? globalThis.Number(object.id) : 0 };
  },

  toJSON(message: DeleteRequest): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteRequest>, I>>(
    base?: I
  ): DeleteRequest {
    return DeleteRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteRequest>, I>>(
    object: I
  ): DeleteRequest {
    const message = createBaseDeleteRequest();
    message.id = object.id ?? 0;
    return message;
  },
};

function createBaseDeleteResponse(): DeleteResponse {
  return { success: false };
}

export const DeleteResponse: MessageFns<DeleteResponse> = {
  encode(
    message: DeleteResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): DeleteResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseDeleteResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): DeleteResponse {
    return {
      success: isSet(object.success)
        ? globalThis.Boolean(object.success)
        : false,
    };
  },

  toJSON(message: DeleteResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<DeleteResponse>, I>>(
    base?: I
  ): DeleteResponse {
    return DeleteResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<DeleteResponse>, I>>(
    object: I
  ): DeleteResponse {
    const message = createBaseDeleteResponse();
    message.success = object.success ?? false;
    return message;
  },
};

function createBaseFindAllRequest(): FindAllRequest {
  return {};
}

export const FindAllRequest: MessageFns<FindAllRequest> = {
  encode(
    _: FindAllRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindAllRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindAllRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): FindAllRequest {
    return {};
  },

  toJSON(_: FindAllRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<FindAllRequest>, I>>(
    base?: I
  ): FindAllRequest {
    return FindAllRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindAllRequest>, I>>(
    _: I
  ): FindAllRequest {
    const message = createBaseFindAllRequest();
    return message;
  },
};

function createBaseFindAllResponse(): FindAllResponse {
  return { products: [] };
}

export const FindAllResponse: MessageFns<FindAllResponse> = {
  encode(
    message: FindAllResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindAllResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindAllResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindAllResponse {
    return {
      products: globalThis.Array.isArray(object?.products)
        ? object.products.map((e: any) => Product.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FindAllResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindAllResponse>, I>>(
    base?: I
  ): FindAllResponse {
    return FindAllResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindAllResponse>, I>>(
    object: I
  ): FindAllResponse {
    const message = createBaseFindAllResponse();
    message.products =
      object.products?.map((e) => Product.fromPartial(e)) || [];
    return message;
  },
};

function createBaseFindByIdsRequest(): FindByIdsRequest {
  return { ids: [] };
}

export const FindByIdsRequest: MessageFns<FindByIdsRequest> = {
  encode(
    message: FindByIdsRequest,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    writer.uint32(10).fork();
    for (const v of message.ids) {
      writer.int32(v);
    }
    writer.join();
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindByIdsRequest {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindByIdsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag === 8) {
            message.ids.push(reader.int32());

            continue;
          }

          if (tag === 10) {
            const end2 = reader.uint32() + reader.pos;
            while (reader.pos < end2) {
              message.ids.push(reader.int32());
            }

            continue;
          }

          break;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindByIdsRequest {
    return {
      ids: globalThis.Array.isArray(object?.ids)
        ? object.ids.map((e: any) => globalThis.Number(e))
        : [],
    };
  },

  toJSON(message: FindByIdsRequest): unknown {
    const obj: any = {};
    if (message.ids?.length) {
      obj.ids = message.ids.map((e) => Math.round(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindByIdsRequest>, I>>(
    base?: I
  ): FindByIdsRequest {
    return FindByIdsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindByIdsRequest>, I>>(
    object: I
  ): FindByIdsRequest {
    const message = createBaseFindByIdsRequest();
    message.ids = object.ids?.map((e) => e) || [];
    return message;
  },
};

function createBaseFindByIdsResponse(): FindByIdsResponse {
  return { products: [] };
}

export const FindByIdsResponse: MessageFns<FindByIdsResponse> = {
  encode(
    message: FindByIdsResponse,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    for (const v of message.products) {
      Product.encode(v!, writer.uint32(10).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FindByIdsResponse {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFindByIdsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.products.push(Product.decode(reader, reader.uint32()));
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FindByIdsResponse {
    return {
      products: globalThis.Array.isArray(object?.products)
        ? object.products.map((e: any) => Product.fromJSON(e))
        : [],
    };
  },

  toJSON(message: FindByIdsResponse): unknown {
    const obj: any = {};
    if (message.products?.length) {
      obj.products = message.products.map((e) => Product.toJSON(e));
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FindByIdsResponse>, I>>(
    base?: I
  ): FindByIdsResponse {
    return FindByIdsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FindByIdsResponse>, I>>(
    object: I
  ): FindByIdsResponse {
    const message = createBaseFindByIdsResponse();
    message.products =
      object.products?.map((e) => Product.fromPartial(e)) || [];
    return message;
  },
};

function createBaseEmpty(): Empty {
  return {};
}

export const Empty: MessageFns<Empty> = {
  encode(_: Empty, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Empty {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseEmpty();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): Empty {
    return {};
  },

  toJSON(_: Empty): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<Empty>, I>>(base?: I): Empty {
    return Empty.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Empty>, I>>(_: I): Empty {
    const message = createBaseEmpty();
    return message;
  },
};

function createBaseProduct(): Product {
  return { id: 0, name: "", description: "", price: 0, availableQuantity: 0 };
}

export const Product: MessageFns<Product> = {
  encode(
    message: Product,
    writer: BinaryWriter = new BinaryWriter()
  ): BinaryWriter {
    if (message.id !== 0) {
      writer.uint32(8).int32(message.id);
    }
    if (message.name !== "") {
      writer.uint32(18).string(message.name);
    }
    if (message.description !== "") {
      writer.uint32(26).string(message.description);
    }
    if (message.price !== 0) {
      writer.uint32(33).double(message.price);
    }
    if (message.availableQuantity !== 0) {
      writer.uint32(40).int32(message.availableQuantity);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): Product {
    const reader =
      input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProduct();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.id = reader.int32();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.description = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.price = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.availableQuantity = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): Product {
    return {
      id: isSet(object.id) ? globalThis.Number(object.id) : 0,
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      description: isSet(object.description)
        ? globalThis.String(object.description)
        : "",
      price: isSet(object.price) ? globalThis.Number(object.price) : 0,
      availableQuantity: isSet(object.availableQuantity)
        ? globalThis.Number(object.availableQuantity)
        : 0,
    };
  },

  toJSON(message: Product): unknown {
    const obj: any = {};
    if (message.id !== 0) {
      obj.id = Math.round(message.id);
    }
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.description !== "") {
      obj.description = message.description;
    }
    if (message.price !== 0) {
      obj.price = message.price;
    }
    if (message.availableQuantity !== 0) {
      obj.availableQuantity = Math.round(message.availableQuantity);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<Product>, I>>(base?: I): Product {
    return Product.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<Product>, I>>(object: I): Product {
    const message = createBaseProduct();
    message.id = object.id ?? 0;
    message.name = object.name ?? "";
    message.description = object.description ?? "";
    message.price = object.price ?? 0;
    message.availableQuantity = object.availableQuantity ?? 0;
    return message;
  },
};

export interface ProductService {
  FindOne(request: FindOneRequest): Promise<FindOneResponse>;
  DecreaseQuantity(
    request: DecreaseQuantityRequest
  ): Promise<DecreaseQuantityResponse>;
  Create(request: CreateRequest): Promise<CreateResponse>;
  Update(request: UpdateRequest): Promise<UpdateResponse>;
  Delete(request: DeleteRequest): Promise<DeleteResponse>;
  FindAll(request: FindAllRequest): Promise<FindAllResponse>;
  FindByIds(request: FindByIdsRequest): Promise<FindByIdsResponse>;
}

export const ProductServiceServiceName = "product.ProductService";
export class ProductServiceClientImpl implements ProductService {
  private readonly rpc: Rpc;
  private readonly service: string;
  constructor(rpc: Rpc, opts?: { service?: string }) {
    this.service = opts?.service || ProductServiceServiceName;
    this.rpc = rpc;
    this.FindOne = this.FindOne.bind(this);
    this.DecreaseQuantity = this.DecreaseQuantity.bind(this);
    this.Create = this.Create.bind(this);
    this.Update = this.Update.bind(this);
    this.Delete = this.Delete.bind(this);
    this.FindAll = this.FindAll.bind(this);
    this.FindByIds = this.FindByIds.bind(this);
  }
  FindOne(request: FindOneRequest): Promise<FindOneResponse> {
    const data = FindOneRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FindOne", data);
    return promise.then((data) =>
      FindOneResponse.decode(new BinaryReader(data))
    );
  }

  DecreaseQuantity(
    request: DecreaseQuantityRequest
  ): Promise<DecreaseQuantityResponse> {
    const data = DecreaseQuantityRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "DecreaseQuantity", data);
    return promise.then((data) =>
      DecreaseQuantityResponse.decode(new BinaryReader(data))
    );
  }

  Create(request: CreateRequest): Promise<CreateResponse> {
    const data = CreateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Create", data);
    return promise.then((data) =>
      CreateResponse.decode(new BinaryReader(data))
    );
  }

  Update(request: UpdateRequest): Promise<UpdateResponse> {
    const data = UpdateRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Update", data);
    return promise.then((data) =>
      UpdateResponse.decode(new BinaryReader(data))
    );
  }

  Delete(request: DeleteRequest): Promise<DeleteResponse> {
    const data = DeleteRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "Delete", data);
    return promise.then((data) =>
      DeleteResponse.decode(new BinaryReader(data))
    );
  }

  FindAll(request: FindAllRequest): Promise<FindAllResponse> {
    const data = FindAllRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FindAll", data);
    return promise.then((data) =>
      FindAllResponse.decode(new BinaryReader(data))
    );
  }

  FindByIds(request: FindByIdsRequest): Promise<FindByIdsResponse> {
    const data = FindByIdsRequest.encode(request).finish();
    const promise = this.rpc.request(this.service, "FindByIds", data);
    return promise.then((data) =>
      FindByIdsResponse.decode(new BinaryReader(data))
    );
  }
}

interface Rpc {
  request(
    service: string,
    method: string,
    data: Uint8Array
  ): Promise<Uint8Array>;
}

type Builtin =
  | Date
  | Function
  | Uint8Array
  | string
  | number
  | boolean
  | undefined;

export type DeepPartial<T> = T extends Builtin
  ? T
  : T extends globalThis.Array<infer U>
  ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U>
  ? ReadonlyArray<DeepPartial<U>>
  : T extends {}
  ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin
  ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & {
      [K in Exclude<keyof I, KeysOfUnion<P>>]: never;
    };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
